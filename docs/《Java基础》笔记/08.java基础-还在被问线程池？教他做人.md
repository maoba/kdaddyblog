---
title: java基础-还在被问线程池？教他做人
date: 2024-01-08 22:24:00
permalink: /pages/83e498/
categories:
  - 《Java基础》笔记
tags:
  - 线程池
  - 小帅面经
author: 
  name: 老猫
  link: https://github.com/maoba
---
## 背景
这是张小帅失业之后的第三场面试。

面试官：“实际开发中用过多线程吧，那聊聊线程池吧”。

“有CachedThreadPool:可缓存线程池,FixedThreadPool:定长线程池.......balabala”。小帅暗暗窃喜，还好把这几种线程池背下来了，看来这次可以上岸了。

面试官点点头，继续问到“那线程池底层是如何实现复用的？”

“额，这个....”

<!-- more -->
寒风中，那个男人的背影在暮色中显得孤寂而凄凉，仿佛与世隔绝，独自面对着无尽的寂寞......

## 概要
如果问到线程池的话，不好好剖析过底层代码，恐怕真的会像小帅那样被问翻吧。

那么在此我们就来好好剖析一下线程池的底层吧。我们大概从如下几个方面着手：

### 什么是线程池
说到线程池，其实我们要先聊到池化技术。

池化技术：我们将资源或者任务放入池子，使用时从池中取，用完之后交给池子管理。通过优化资源分配的效率，达到性能的调优。

池化技术优点：
1. 资源被重复使用，减少了资源在分配销毁过程中的系统的调度消耗。比如，在IO密集型的服务器上，并发处理过程中的子线程或子进程的创建和销毁过程，带来的系统开销将是难以接受的。所以在业务实现上，通常把一些资源预先分配好，如线程池，数据库连接池，Redis连接池，HTTP连接池等，来减少系统消耗，提升系统性能。

2. 池化技术分配资源，会集中分配，这样有效避免了碎片化的问题。

3. 可以对资源的整体使用做限制，相关资源预分配且只在预分配是生成，后续不再动态添加，从而限制了整个系统对资源的使用上限。

所以我们说线程池是提升线程可重复利用率、可控性的池化技术的一种。

### 线程池的使用
#### 多线程发送邮件案例
现在我们有这样一个场景，上层有业务系统批量调用底层进行发送邮件，废话不多，直接上代码：

![demo](https://cdn.ktdaddy.com/architecture/biz/threadpool/threadPool_demo.png)

最终运行输出结果为：
```java
由线程：pool-1-thread-1 发送第：0封邮件
由线程：pool-1-thread-2 发送第：1封邮件
由线程：pool-1-thread-1 发送第：2封邮件
由线程：pool-1-thread-2 发送第：3封邮件
由线程：pool-1-thread-1 发送第：4封邮件
由线程：pool-1-thread-1 发送第：6封邮件
由线程：pool-1-thread-2 发送第：5封邮件
由线程：pool-1-thread-1 发送第：7封邮件
由线程：pool-1-thread-2 发送第：8封邮件
由线程：pool-1-thread-1 发送第：9封邮件
```
上面的例子中从结果来看是10封邮件分别由两条线程发送出去了，上图可见，我们给ThreadPoolExecutor这个执行器分别指定了七个参数。那么参数的含义到底是什么呢？接下来咱们层层抽丝剥茧。


#### 构造函数说明
大家估计会有疑问，线程池的种类那么多，案例中为什么要用TheadPoolExecutor类呢，其他的种类是由TheadPoolExecutor通过不同的入参定义出来的，所以我们直接拿ThreadPoolExecutor来看。

我们先来看一下ThreadPoolExecutor的继承关系，有个宏观印象：

![宏观继承](https://cdn.ktdaddy.com/architecture/biz/threadpool/TheadPoolHigh.png)

我们再来看一下ThreadPoolExecutor的构造方法：

![构造方法](https://cdn.ktdaddy.com/architecture/biz/threadpool/constructor.png)

下面我们来解释一下几个参数的含义：

1. corePoolSize： 核心线程数。

2. maximumPoolSize： 最大线程数。

3. keepAliveTime： 线程池中线程的最大闲置生命周期。

4. unit： 针对keepAliveTime的时间单位。

5. workQueue： 阻塞队列。

6. threadFactory： 创建线程的线程工厂。

7. handler： 拒绝策略。

大家对上述的含义初步有个概念。

上述我们提及不同的参数进行组合固定提供给了我们一些封装好的线程商品池，我们看一下用法说明。

1. newCachedThreadPool：
创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。

2. newFixedThreadPool
创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。

3. newScheduledThreadPool
创建一个定长线程池，支持定时及周期性任务执行。

4. newSingleThreadScheduleExecutor
创建一个单线程执行程序，它可安排在给定延迟后运行命令或者定期地执行。（注意，如果因为在关闭前的执行期间出现失败而终止了此单个线程，那么如果需要，一个新线程会代替它执行后续的任务）。可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。与其他等效的 newScheduledThreadPool(1) 不同，可保证无需重新配置此方法所返回的执行程序即可使用其他的线程。

5. newSingleThreadExecutor
创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序（FIFO， LIFO， 优先级）执行。


