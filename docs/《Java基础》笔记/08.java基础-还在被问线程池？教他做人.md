---
title: java基础-还在被问线程池？教他做人
date: 2024-01-08 22:24:00
permalink: /pages/83e498/
categories:
  - 《Java基础》笔记
tags:
  - 线程池
  - 小帅面经
author: 
  name: 老猫
  link: https://github.com/maoba
---
## 背景
这是张小帅失业之后的第三场面试。

面试官：“实际开发中用过多线程吧，那聊聊线程池吧”。

“有CachedThreadPool:可缓存线程池,FixedThreadPool:定长线程池.......balabala”。小帅暗暗窃喜，还好把这几种线程池背下来了，看来这次可以上岸了。

面试官点点头，继续问到“那线程池底层是如何实现复用的？”

“额，这个....”

<!-- more -->
寒风中，那个男人的背影在暮色中显得孤寂而凄凉，仿佛与世隔绝，独自面对着无尽的寂寞......

## 概要
如果问到线程池的话，不好好剖析过底层代码，恐怕真的会像小帅那样被问翻吧。

那么在此我们就来好好剖析一下线程池的底层吧。我们大概从如下几个方面着手：

### 什么是线程池
说到线程池，其实我们要先聊到池化技术。

池化技术：我们将资源或者任务放入池子，使用时从池中取，用完之后交给池子管理。通过优化资源分配的效率，达到性能的调优。

池化技术优点：
1. 资源被重复使用，减少了资源在分配销毁过程中的系统的调度消耗。比如，在IO密集型的服务器上，并发处理过程中的子线程或子进程的创建和销毁过程，带来的系统开销将是难以接受的。所以在业务实现上，通常把一些资源预先分配好，如线程池，数据库连接池，Redis连接池，HTTP连接池等，来减少系统消耗，提升系统性能。

2. 池化技术分配资源，会集中分配，这样有效避免了碎片化的问题。

3. 可以对资源的整体使用做限制，相关资源预分配且只在预分配是生成，后续不再动态添加，从而限制了整个系统对资源的使用上限。

所以我们说线程池是提升线程可重复利用率、可控性的池化技术的一种。

### 线程池的使用
#### 多线程发送邮件案例
现在我们有这样一个场景，上层有业务系统批量调用底层进行发送邮件，废话不多，直接上代码：

![demo](https://cdn.ktdaddy.com/architecture/biz/threadpool/threadPool_demo.png)

最终运行输出结果为：
```java
由线程：pool-1-thread-1 发送第：0封邮件
由线程：pool-1-thread-2 发送第：1封邮件
由线程：pool-1-thread-1 发送第：2封邮件
由线程：pool-1-thread-2 发送第：3封邮件
由线程：pool-1-thread-1 发送第：4封邮件
由线程：pool-1-thread-1 发送第：6封邮件
由线程：pool-1-thread-2 发送第：5封邮件
由线程：pool-1-thread-1 发送第：7封邮件
由线程：pool-1-thread-2 发送第：8封邮件
由线程：pool-1-thread-1 发送第：9封邮件
```
上面的例子中从结果来看是10封邮件分别由两条线程发送出去了，上图可见，我们给ThreadPoolExecutor这个执行器分别指定了七个参数。那么参数的含义到底是什么呢？接下来咱们层层抽丝剥茧。


#### 构造函数说明
大家估计会有疑问，线程池的种类那么多，案例中为什么要用TheadPoolExecutor类呢，其他的种类是由TheadPoolExecutor通过不同的入参定义出来的，所以我们直接拿ThreadPoolExecutor来看。

我们先来看一下ThreadPoolExecutor的继承关系，有个宏观印象：

![宏观继承](https://cdn.ktdaddy.com/architecture/biz/threadpool/TheadPoolHigh.png)

我们再来看一下ThreadPoolExecutor的构造方法：

![构造方法](https://cdn.ktdaddy.com/architecture/biz/threadpool/constructor.png)

下面我们来解释一下几个参数的含义：

1. corePoolSize： 核心线程数。

2. maximumPoolSize： 最大线程数。

3. keepAliveTime： 线程池中线程的最大闲置生命周期。

4. unit： 针对keepAliveTime的时间单位。

5. workQueue： 阻塞队列。

6. threadFactory： 创建线程的线程工厂。

7. handler： 拒绝策略。

大家对上述的含义初步有个概念。

#### 工作流程概述
看了上面的构造函数字段大家估计也还是优点懵的，尤其是从来没有接触过商品池的小伙伴。所以老猫又撸了一张商品池的大概的工作流程图，方便大家把这些概念串起来。

![大概流程](https://cdn.ktdaddy.com/architecture/biz/threadpool/threadFunc.png)

上图中老猫标记了四条线，简单介绍一下（当然上图若有问题，也希望大家能够指出来）。

1. 当发起任务时候，会计算线程池中存在的线程数量与核心线程数量（corePoolSize）进行比较，如果小于，则在线程池中创建线程，否则，进行下一步判断。 
2. 如果不满足条件1，则会将任务添加到阻塞队列中。等待线程池中的线程空闲下来后，获取队列中的任务进行执行。
3. 但是条件2中如果阻塞队列满了之后，此时又会重新获取当前线程的数量和最大线程数(maximumPoolSize)进行比较，如果发现小于最大线程数，那么继续添加到线程池中即可。
4. 如果都不满足上述条件，那么此时会放到拒绝策略中。

#### execute流程剖析
接下来我们来看一下执行theadPoolExecutor.execute()的时候到底发生了什么。先来看一下源码：
```java
public void execute(Runnable command) {
        if (command == null)
            throw new NullPointerException();
        int c = ctl.get();
        if (workerCountOf(c) < corePoolSize) {
            if (addWorker(command, true))
                return;
            c = ctl.get();
        }
        if (isRunning(c) && workQueue.offer(command)) {
            int recheck = ctl.get();
            if (! isRunning(recheck) && remove(command))
                reject(command);
            else if (workerCountOf(recheck) == 0)
                addWorker(null, false);
        }
        else if (!addWorker(command, false))
            reject(command);
    }
```
##### ctl变量
进入执行源码之后我们首先看到的是ctl,只知道ctl中拿到了一个int数据至于这个数值有什么用，目前不知道，接着看涉及的相关代码，老猫将相关的代码解读放到源码中进行注释。
```java
    //通过ctl获取线程池的状态以及包含的线程数量
    private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
    private static final int COUNT_BITS = Integer.SIZE - 3;   // COUNT_BITS = 32-3 = 29
    /**001左移29位
     * 00100000 00000000 00000000 00000000
     * 操作减1
     * 00011111 11111111 11111111 11111111
     * 换成十进制：COUNT_MASK = 536870911
     */
    private static final int COUNT_MASK = (1 << COUNT_BITS) - 1;

    //运行状态 
    private static final int RUNNING    = -1 << COUNT_BITS;
    private static final int SHUTDOWN   =  0 << COUNT_BITS;
    private static final int STOP       =  1 << COUNT_BITS;
    private static final int TIDYING    =  2 << COUNT_BITS;
    private static final int TERMINATED =  3 << COUNT_BITS; 

    private static int ctlOf(int rs, int wc) { return rs | wc; }
```
