---
title: 小帅面试记-又栽了，惨遭ThreadLocal夺命连环问
date: 2024-01-31 22:32:30
permalink: /pages/be417c/
categories:
  - 《Java基础》笔记
tags:
   - ThreadLocal
   - 小帅面经
titleTag: 原创    
author: 
  name: 老猫
  link: https://github.com/maoba
---
## 故事
地铁上，小帅无力地倚靠着杆子，脑子里尽是刚才面试官的夺命连环问，“用过TheadLocal么？ThreadLocal是如何解决共享变量访问的安全性的呢？你觉得啥场景下会用到TheadLocal? 我们在日常用ThreadLocal的时候需要注意什么？ThreadLocal在高并发场景下会造成内存泄漏吗？为什么......”

这些问题，如同阴影一般，在小帅的脑海里挥之不去。

是的，他万万没想到，自诩“多线程小能手”的他栽在了ThreadLocal上。

这是小帅苦投了半个月简历之后才拿到的面试机会，然而又丧失了。当下行情实在是卷到了极点。

都两个月了，面试机会少，居然还每次都被问翻，这样下去真要回老家另谋出路了，小帅内心五味成杂......

小伙伴们，试问一下，如果是你，面对上述的问题，你能否对答如流呢？

## 概要
既然被问到了，那么作为事后诸葛的老猫就和大家一起来接面试官的招吧。

我们将从以下点来全面剖析一下ThreadLocal。


## 基本篇
### 什么是ThreadLocal？
ThreadLocal英文翻译过来就是：线程本地量，它其实是一种线程的隔离机制，保障了多线程环境下对于共享变量访问的安全性。

看到上面的定义之后，那么问题就来了，ThreadLocal是如何解决共享变量访问的安全性的呢？

其实ThreadLocal为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量。由于副本都归属于各自的线程，所以就不存在多线程共享的问题了。

便于理解，我们看一下下图。

![结构图](https://cdn.ktdaddy.com/threadlocal/p1.png)

至于上述图中提及的threadLocals(ThreadLocalMap)，我们后文看源代码的时候再继续来看。大家心中暂时有个概念。


#### 既然都是保证线程访问的安全性，那么和Synchronized区别是什么呢？
在上面聊到共享变量访问安全性的问题上，其实大家还会很容易想起另外一个关键字Synchronized。聊聊区别吧，整理了一张图，看起来可能会更加直观一些，如下。

![对比](https://cdn.ktdaddy.com/threadlocal/p2.png)

通过上图，我们发现ThreadLocal其实是一种线程隔离机制。Synchronized则是一种基于Happens-Before规则里的监视器锁规则从而保证同一个时刻只有一个线程能够对共享变量进行更新。

Synchronized加锁会带来性能上的下降。ThreadLocal采用了空间换时间的设计思想，也就是说每个线程里面都有一个专门的容器来存储共享变量的副本信息，然后每个线程只对自己的变量副本做相对应的更新操作，这样避免了多线程锁竞争的开销。


### ThreadLocal的使用
上面说了这么多，咱们来使用一下。就拿SimpleDateFormat来做个例子。当然也会有一道这样的面试题，SimpleDateFormat是否是线程安全的？在阿里Java开发规约中，有强制性的提到SimpleDateFormat 是线程不安全的类。其实主要的原因是由于多线程操作SimpleDateFormat中的Calendar对象引用，然后出现脏读导致的。

踩坑代码：
```java
/**
 * @author 公众号：程序员老猫
 * @date 2024/2/1 22:58
 */
public class DateFormatTest {
    private static final SimpleDateFormat simpleDateFormat =
            new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");

    public static Date parse(String dateString) {
        Date date = null;
        try {
            date = simpleDateFormat.parse(dateString);
        } catch (ParseException e) {
            e.printStackTrace();
        }
        return date;
    }

    public static void main(String[] args) {
        ExecutorService executorService = Executors.newFixedThreadPool(20);

        for (int i = 0; i < 20; i++) {
            executorService.execute(()->{
                System.out.println(parse("2024-02-01 23:34:30"));
            });
        }
        executorService.shutdown();
    }
}
```
上述咱们通过线程池的方式针对SimpleDateFormat进行了测试（如果大家需要深入了解一下线程池的相关原理，可以戳“[线程池](https://mp.weixin.qq.com/s/xWbSPHJG_TztJpM4Pv9knw)”）。其输出结果如下。

![日期](https://cdn.ktdaddy.com/threadlocal/p3.png)

我们可以看到刚开始好好的，后面就异常了。

我们通过ThreadLocal的方式将其优化一下。代码如下：

```java
/**
 * @author 公众号：程序员老猫
 * @date 2024/2/1 22:58
 */
public class DateFormatTest {

    private static ThreadLocal<SimpleDateFormat> dateFormatThreadLocal =
            ThreadLocal.withInitial(() -> new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"));

    public static Date parse(String dateString) {
        Date date = null;
        try {
            date = dateFormatThreadLocal.get().parse(dateString);
        } catch (ParseException e) {
            e.printStackTrace();
        }
        return date;
    }

    public static void main(String[] args) {
        ExecutorService executorService = Executors.newFixedThreadPool(10);

        for (int i = 0; i < 20; i++) {
            executorService.execute(()->{
                System.out.println(parse("2024-02-01 23:34:30"));
            });
        }
        executorService.shutdown();
    }
}
```
运行了一下,完全正常了。
```
Thu Feb 01 23:34:30 CST 2024
Thu Feb 01 23:34:30 CST 2024
Thu Feb 01 23:34:30 CST 2024
Thu Feb 01 23:34:30 CST 2024
Thu Feb 01 23:34:30 CST 2024
Thu Feb 01 23:34:30 CST 2024
Thu Feb 01 23:34:30 CST 2024
Thu Feb 01 23:34:30 CST 2024
Thu Feb 01 23:34:30 CST 2024
```

### TheadLocal使用场景
那么我们什么时候会用到ThreadLocal呢？

1. 上面针对SimpleDateFormat的封装也算是一个吧。

2. 用来替代参数链传递：在编写API接口时，可以将需要传递的参数放入ThreadLocal中，从而不需要在每个调用的方法上都显式地传递这些参数。这种方法虽然不如将参数封装为对象传递来得常见，但在某些情况下可以简化代码结构。

3. 数据库连接和会话管理：在某些应用中，如Web应用程序，ThreadLocal可以用来保持对数据库连接或会话的管理，以简化并发控制并提高性能。例如，可以使用ThreadLocal来维护一个连接池，使得每个请求都能共享相同的连接，而不是每次都需要重新建立连接。

4. 全局存储信息：例如在前后端分离的应用中，ThreadLocal可以用来在服务端维护用户的上下文信息或者一些配置信息，而不需要通过HTTP请求携带大量的用户信息。这样做可以在不改变原有架构的情况下，提供更好的用户体验。

如果大家还能想到其他使用的场景也欢迎留言。

## 升华篇
### ThreadLocal原理
上述其实咱们聊的相对而言还是比较浅的。那么接下来，咱们丰富一下之前提到的结构图，从源代码侧深度剖一下ThreadLocal吧。

![结构图](https://cdn.ktdaddy.com/threadlocal/p4.png)

关于ThreadLocalMap，核心代码如下：
```java
static class Entry extends WeakReference<ThreadLocal<?>> {
            /** The value associated with this ThreadLocal. */
            Object value;

            Entry(ThreadLocal<?> k, Object v) {
                super(k);
                value = v;
            }
        }

/**
 * Entry数组
 */
private Entry[] table;

ThreadLocalMap(ThreadLocal<?> firstKey, Object firstValue) {
            table = new Entry[INITIAL_CAPACITY];
            int i = firstKey.threadLocalHashCode & (INITIAL_CAPACITY - 1);
            table[i] = new Entry(firstKey, firstValue);
            size = 1;
            setThreshold(INITIAL_CAPACITY);
}
}
```

在源码中涉及比较核心的

### 高并发场景下ThreadLocal会造成内存泄漏吗？
