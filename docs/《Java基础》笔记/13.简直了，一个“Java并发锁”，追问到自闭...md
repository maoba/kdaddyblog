---
title: 简直了，被“Java并发锁”问题追问到自闭...
date: 2024-03-28 22:23:27
permalink: /pages/6cf210/
categories:
  - 《Java基础》笔记
tags:
  - 小帅面经
  - Java并发锁
titleTag: 原创   
author: 
  name: 老猫
  link: https://github.com/maoba
---
## 故事
地铁上，小帅双目空洞地望着窗外...绝望，发自内心地感到绝望...

距离失业已经过去两个月了，这是小帅接到的第四次面试邀请。“回去等通知吧...”,简简单单的六个字，把小帅的心再次打入了冰窖。

上次“【[ThreadLocal问出花](https://mp.weixin.qq.com/s/7JbXoc931nnTIpKN7UsTog)】”，小帅其实也有吸取教训得，这次对于多线程的问题还是做了很多准备的...可是没想到这次的结果居然也还是这样。

“Java中的锁了解吧？介绍一下吧”，面试官不紧不慢地问到。

“乐观锁、悲观锁、公平锁、非公平锁，然后平时咱们的synchronized是基于.....”小帅把知道的所有关于锁的基本都回答了一遍。

面试官对他笑了笑，“就这些吗？还有呢？比如自旋锁、可重入锁、独占锁....并且说一下你的理解，或者聊一下使用场景的优劣吧。”

“额.....以前好像看到过...”小帅语无伦次地回答到。

“嗯，行吧，之前的那些答得可以的，不过一会我这边有个会，要不今天咱们就聊到这里？回去等通知吧...”

## Java中让人眼花缭乱的锁你是否真的一一清楚了？
试问这样一个大而宽的问题，大家能够总结全吗，如果让各位来回答，能否回答完全呢？

我们在实际的并发编程中，常常遇到多个线程访问一个共享变量的情况，当同时对共享变量进行读写操作的时候，就会产生数据不一致的情况。为了保证资源获取的有序性，我们就常常会用到并发锁。

那么接下来咱们就来聊聊这些Java并发锁的理解吧。我们将从以下这些方面来一起回顾一下Java中的并发锁。


## 乐观锁和悲观锁：线程是否锁住同步资源
大家其实对乐观锁和悲观锁听说的比较多一些，所以咱们就先来聊聊这两种类型的锁。这两种类型的锁，本质区分是要看线程是否锁住同步资源。

先来看一下悲观锁。悲观锁就是每次去拿数据的时候都会认为别人会修改数据，所以在读取数据的时候都会上锁。这样就会导致线程临时阻塞。

![悲观锁](https://cdn.ktdaddy.com/lock/01.png)

再来看一下乐观锁，乐观锁就是每次在拿数据的时候都假设别人不会修改数据，所以都不会进行上锁；只有在更新数据的时候才去判断之前有没有别的线程更新了这条数据。如果没有更新，那么当前线程会自己修改数据并且写入成功。如果数据已经被其他线程更新了，那么会报错或者自动重试，例如下图。

![乐观锁](https://cdn.ktdaddy.com/lock/02.png)

上述两种锁，并没有优劣之分。只是看相关的场景然后分别去使用。

乐观锁：适用于写少读多的场景。因为不用上锁，释放锁，省去了锁的开销，从而提升了吞吐量。

悲观锁：适用于写多读少的场景。因为线程竞争激烈，如果使用乐观锁会导致线程不断进行重试，反而降低吞吐量。

## 共享锁和独占锁：多个线程是否共享同一把锁
并发场景下，如果多个线程能够共享一把锁，那么就是所谓的共享锁，如果不能，那么则为独占锁（其他命名：排他锁或者独享锁）。

共享锁指锁可以被多个线程持有。如果一个线程对数据加上共享锁，那么其他线程只能对数据再加共享锁，不能加独占锁。另外的共享锁的线程只能读数据，不能修改数据。如下图。

![共享锁](https://cdn.ktdaddy.com/lock/03.png)

例如，ReentrantReadWriteLock的读锁是共享锁。具体伪代码如下：

```java 
import java.util.concurrent.locks.ReentrantReadWriteLock;

public class ReadWriteLockDemo {
    private ReentrantReadWriteLock lock = new ReentrantReadWriteLock();

    public void readData() {
        lock.readLock().lock(); // 获取读锁
        try {
            // 读取共享数据
        } finally {
            lock.readLock().unlock(); // 释放读锁
        }
    }
}

```

独占锁是指锁一次只能被一个线程持有，如果一个线程对数据加上独占锁，那么其他的线程则不能对该数据再加任何类型的锁。如果一个线程获取独占锁，那么则该线程既可以读数据又可以修改数据。

![独占锁](https://cdn.ktdaddy.com/lock/04.png)

对于独占锁来说，大家比较熟悉的就是synchronized和J.U.C包中的Lock实现类。

大家可能也听说过互斥锁，其实互斥锁就是独占锁的一种常规实现。