---
title: 跟着老猫来搞GO，基础进阶
date: 2021-11-03 21:34:44
permalink: /pages/8ab3b2/
categories: 
  - 《Go语言》
tags: 
  - GO开发
author: 
  name: 老猫
  link: https://github.com/maoba
---

回顾一下上一篇博客，主要是和大家分享了GO语言的基础语法，其中包含变量定义，基本类型，条件语句，循环语句。那本篇呢就开始和大家同步一下GO语言基础的进阶。

<!-- more -->

### 函数的定义

上次其实在很多的DEMO中已经写出来一些函数了，但是没有讲清楚其函数定义。接下来我们同样地要举例说明一下，直接看代码。

```go
func calculate(a,b int, op string) int {
	switch op {
	case "+":
		return a + b
	case "-":
		return a - b
	case "*":
		return a * b
	case "/":
		return a / b
	default:
		panic("unsupported op")
	}
}
```

以上是一个比较简单的计算两个整数加减乘除运算的一个函数，首先我们可以看到的是函数的定义其实也是遵循着变量的定义方式，咱们先定义函数的名称，然后才是函数的返回值。当然函数中的参数定义也是如此。

除此以外，其实GO语言相对于其他语言来说有一个比较骚的操作，就是他可以存在多个返回值。例如下面咱们写一个除法的例子，就是大家小学就学过的除不尽的时候存在余数的情况。下面我们来看一个函数。

```go
func div(a int, b int) (int,int){
	return a / b, a % b
}
```

大家看到上面这个返回值有什么感想，其实这最终的两个返回值是没有体现任何业务意义的，咱们无法区分最终返回的结果到底是干什么用的。当然GO语言其实也发现了这个弊端，所以呢，我们的返回值的名称也是可以定义的，具体如下，我们命名除法得到的商为q，余数为r，那么我们改进之后就得到如下：

```go
func div(a int, b int) (q ,r int){
	return a / b, a % b
}
```

如果这样的话我们main调用得到结果就可以这么获取

```go
func main() {
	fmt.Println(div(4,3))
	q,r := div(5,6)
	fmt.Println(q,r)
}
```

那么此时问题又来了，如果我们只要其中的一个商，余数不要，这又是如何写呢，因为我们都知道go的语法中，定义出来的变量后面都得用到才行，否则的话会报编译错误，那其实我们直接用"_"来替换即可。具体代码块如下

```go
func main() {
	q,_ := div(5,6)
	fmt.Println(q)
}
```

这样话咱们就可以只获取其中一个值即可。

其实GO语言函数式编程编程的语言，函数是非常重要的，所以咱们再高端一点的函数的写法是可以将函数本身作为一个参数传入函数的，说的比较绕，其实本身开始去接受的时候也是有点难理解，老猫在此先把例子写一下，大家试着去理解一下，当然后面的话老猫会有更详细地对函数式编程的介绍，具体的例子如下

```go
func apply(op func(int,int) int,a,b int) int{
	fmt.Printf("Calling %s with %d,%d\n",
		runtime.FuncForPC(reflect.ValueOf(op).Pointer()).Name(),a,b)
	return op(a,b)
}
```

我们对GO语言的函数来做一个简单的总结：

- 返回值类型写在后面
- 可以返回多个值
- 函数可以作为参数
- 没有默认参数，可变参数，重载等等

### 指针

#### 相关定义

关注老猫的应该大多数是软件专业的同学，不晓得大家有没有熟悉过C语言，C语言中其实也有指针，C语言的指针相对还是比较难的。其实GO语言也有指针，相对而言比较简单，因为GO语言的指针不能运算。

指针说白了就是一个指针指向了一个值的内存地址。

GO语言中的去地址符为&，放到变量以前的话就会返回相应的变量内存地址。看个例子如下：

```go
package main

import "fmt"
func main() {
   var a int = 10  
   fmt.Printf("变量的地址: %x\n", &a  )
}
```

这个呢，其实就是GO语言的地址获取方式，那我们如何去访问它呢？那么我们的指针就登场了，如下代码示例

```go
var var_name *var-type
```

var-type为指针类型，var_name为指针变量名称，*用于指定变量是作为一个指针。那么我们再来看下面的例子：

```go
var ip *int        /* 指向整型*/
var fp *float32    /* 指向浮点型 */
```

那么以上其实就是定义了两个指针，分别指向int以及float32。

#### 使用指针

```go
package main

import "fmt"

func main() {
   var a int= 20   /* 声明实际变量 */
   var ip *int        /* 声明指针变量 */

   ip = &a  /* 指针变量的存储地址 */

   fmt.Printf("a 变量的地址是: %x\n", &a  )

   /* 指针变量的存储地址 */
   fmt.Printf("ip 变量储存的指针地址: %x\n", ip )

   /* 使用指针访问值 */
   fmt.Printf("*ip 变量的值: %d\n", *ip )
}
```

那么我们得到的结果为

```
a 变量的地址是: 20818a220
ip 变量储存的指针地址: 20818a220
*ip 变量的值: 20
```

GO语言其实也会存在空指针， 当一个指针被定义后没有分配到任何变量时，它的值为 nil。  nil 指针也称为空指针。  nil在概念上和其它语言的null、None、nil、NULL一样，都指代零值或空值。  一个指针变量通常缩写为 ptr。 

如下例子

```go
package main

import "fmt"

func main() {
   var  ptr *int
   fmt.Printf("ptr 的值为 : %x\n", ptr  )
}
```

结果

```
ptr 的值为 : 0
```

那么我们一般对空指针的判断即为

```go
if(ptr != nil)     /* ptr 不是空指针 */
if(ptr == nil)    /* ptr 是空指针 */
```

以上就是老猫带大家入一下指针的门，当然也是老猫的入门。后续，我们会在实际的例子中来慢慢体会指针的用法。

#### 值传递以及引用传递

那么什么是值传递，什么是引用传递？我们简单地来看一段C++ 的代码，具体如下：

```c++
void pass_by_val(int a) {
   a++;
}
void pass_by_ref(int &a){
  a++;
}
int main(){
   int a = 3;
   pass_by_val(a);
   printf("After pass_by_val:%d\n",a);
   pass_by_ref(a);
   printf("After pass_by_ref:%d\n",a);
}
```

上面两个方法，其中一个是值传递一个是引用传递，那么最终输出的结果是多少呢？大家可以先思考一下。其实答案为上面是3下面是4，那么为什么呢？

我们来看第一种，第一种的话是值传递，值传递的方式其实在上面的例子中可以这么理解，该函数是将main中的值拷贝一份放到了函数中，虽然在函数中加了1，但是外层原始的那个值还是3，所以最终输出的也还是3。

我们再来看另外一种，引用传递，从入参来看的话，其实里面的a以及外面的a所引用的都是同一个地址，所以当内部函数对a进行自增的时候，外面的函数a的值就发生了变化，变成了4。

那么我们的GO是值传递还是引用传递，其实GO语言只有值传递。

 大家可能有点懵了，其实很多时候，大家不用太过纠结，因为在实际的用法中我们往往通过函数return的值就能解决相关问题。

### 写在最后

上面呢，其实老猫和大家分享了GO语言的函数定义，以及一个比较重要的指针的概念，在后面的学习中，我们来更加深入地去体会。在实践中去慢慢加深印象。当然上面的例子也希望大家能够照着写一下，运行着体会一下。有不理解的欢迎大家一块沟通一起进步。

