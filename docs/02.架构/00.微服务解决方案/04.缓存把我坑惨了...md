---
title: 缓存把我坑惨了..
date: 2024-03-10 21:42:41
permalink: /pages/c40d7c/
categories:
  - 架构
  - 微服务解决方案
tags:
  - 缓存
author: 
  name: 老猫
  link: https://github.com/maoba
---
## 故事
春天，办公室外的世界总是让人神往的，小猫带着耳机，托着腮帮，望着外面美好的春光神游着...

一声不和谐的座机电话声打破这份本该属于小猫的宁静，“hi，小猫，线上有个客户想购买A产品规格的商品，投诉说下单总是失败，帮忙看一下啥原因。”客服部小姐姐甜美的声音从电话那头传来。“哦哦，好，我看一下，把商品编号发一下吧......”

由于前一段时间的系统熟悉，小猫对现在的数据表模型已经了然于胸，当下就直接定位到了商品规格信息表，发现数据库中客户想购买的规格已经被下架了，但是前端的缓存好像并没有被刷新。

小猫在系统中找到了之前开发人员留的后门接口，直接curl语句重新刷新了一下接口，缓存问题搞定了。

关于商品缓存和数据库不一致的情况，其实小猫一周会遇到好几个这样的客诉，他深受DB以及缓存不一致的苦，于是他下定决心想要从根本上解决问题，而不是curl调用后门接口......

## 写在前面
小猫的态度其实还是相当值得肯定的，当他下定决心从根本上排查问题的时候开始，小猫其实就是一名合格而且负责的研发，这也是我们每一位软件研发人员所需要具备的处理事情的态度。

在软件系统演进的过程中，只有我们在修复历史遗留的问题的时候，才是真正意义上地对系统进行了维护，如果我们使用一些极端的手段(例如上述提到的后门接口curl语句)来保持古老而陈腐的代码继续工作的时候，这其实是一种苟且。一旦系统有了问题，我们其实就需要及时进行优化修复，否则会形成不好的示范，更多的后来者倾向于类似的方式解决问题，这也是为什么FixController存在的原因，这其实就是系统腐化的标志。

言归正传，关于缓存和DB不一致相信大家在日常开发的过程中都有遇到过，那么我们接下来就和大家好好盘一盘，缓存和DB不一致的时候，咱们是如何去解决的。接下来，大家会看到解决方案以及实战。


## 常规接口缓存读取更新
![常规缓存读取](https://cdn.ktdaddy.com/cache/cache01.png)

看到上面的图，我们可以清晰地知道缓存在实际场景中的工作原理。
1. 发生请求的时候，优先读取缓存，如果命中缓存则返回结果集。
2. 如果缓存没有命中，则回归数据库查询。
3. 将数据库查询得到的结果集再次同步到缓存中，并且返回对应的结果集。

这是大家比较熟悉的缓存使用方式，可以有效减轻数据库压力，提升接口访问性能。但是在这样的一个架构中，会有一个问题，就是一份数据同时保存在数据库和缓存中，如果数据发生变化，需要同时更新缓存和数据库，由于更新是有先后顺序的，并且它不像数据库中多表事务操作满足ACID特性，所以这样就会出现数据一致性的问题。

## DB和缓存不一致方案与实战DEMO
关于缓存和DB不一致，其实无非就是以下四种解决方案：

1. 先更新缓存，再更新数据库
2. 先更新数据库，再更新缓存
3. 先删除缓存，后更新数据库
4. 先更新数据库，后删除缓存

### 先更新缓存，再更新数据库(不建议)

![更新缓存后更新数据库](https://cdn.ktdaddy.com/cache/cache02.png)

这种方案其实是不提倡的，这种方案存在的问题是缓存更新成功，但是更新数据库出现异常了。这样会导致缓存数据与数据库数据完全不一致，而且很难察觉，因为缓存中的数据一直都存在。


### 先更新数据库，再更新缓存

先更新数据库，再更新缓存，如果缓存更新失败了，其实也会导致数据库和缓存中的数据不一致，这样客户端请求过来的可能一直就是错误的数据。

![更新数据库之后更新缓存](https://cdn.ktdaddy.com/cache/cache03.png)

### 先删除缓存，后更新数据库
这种场景在并发量比较小的时候可能问题不大，立项情况是应用访问缓存的时候，发现缓存中的数据是空的，就会从数据库中加载并且保存到缓存中，这样数据是一致的，但是在高并发的极端情况下，由于删除缓存和更新数据库非原子行为，所以这期间就会有其他的线程对其访问。于是，如下图。

![高并发删除缓存，后更新数据库](https://cdn.ktdaddy.com/cache/cache04.png)
解释一下上图，老猫罗列了两个线程，分别是线程1和线程2。
1. 线程1会先删除缓存中的数据，但是尚未去更新数据库。
2. 此时线程2看到缓存中的数据是空的，就会去数据库中查询该值，并且重新更新到缓存中。
3. 但是此时线程1并没有更新成功，或者是事务还未提交（MySQL的事务隔离级别，会导致未提交的事务数据不会被另一个线程看到），由于线程2快于线程1，所以线程2去数据库查询得到旧值。
4. 这种情况下最终发现缓存中还是为旧值，但是数据库中却是最新的。

由此可见，这种方案其实也并不是完美的，在高并发的情况下还是会有问题。那么下面的这种总归是完美的了吧，有小伙伴肯定会这么认为，让我们一起来分析一下。

### 先更新数据库，后删除缓存
先说结论，其实这种方案也并不是完美的。咱们通过下图来说一个比较极端的场景。

![更新数据库，后删除缓存](https://cdn.ktdaddy.com/cache/cache05.png)

上图中，我们执行的时间顺序是按照数字由小到大进行。在高并发场景下，我们说一下比较极端的场景。

上面有线程1和线程2两个线程。其中线程1是读线程，当然它也会负责将读取的结果集同步到缓存中，线程2是写线程，主要负责更新和重新同步缓存。
1. 由于缓存失效，所以线程1开始直接查询的就是DB。
2. 此时写线程2开始了，由于它的速度较快，所以直接完成了DB的更新和缓存的删除更新。
3. 当线程2完成之后，线程1又重新更新了缓存，那此时缓存中被更新之后的当然是旧值了。

如此，咱们又发现了问题，又出现了数据库和缓存不一致的情况。

那么显然上面的这四种方案其实都多多少少会存在问题，那么究竟如何去保持数据库和缓存的一致性呢？

### 保证强一致性
如果有人问，那我们能否保证缓存和DB的强一致性呢？回答当然是肯定的，那就是针对更新数据库和刷新缓存这两个动作加上锁。当DB和缓存数据完成同步之后再去释放，一旦其中任何一个组件更新失败，我们直接逆向回滚操作。我们可能还得做快照便于其历史缓存重写。那这种设计显然代价会很大。

其实在很大一部分情况下，要求缓存和DB数据强一致大部分都是伪需求。我们可能只要达到最终尽量保持缓存一致即可。有缓存要求的大部分业务其实也是能接受数据在短期内不一致的情况。所以我们就可以使用下面的这两种最终一致性的方案。

### 错误重试达到最终一致
如下示意图所示：

![基于消息队列](https://cdn.ktdaddy.com/cache/cache06.png)

上面的图中我们看到。当然上述老猫只是画了更新线程，其实读取线程也一样。
1. 更新线程优先更新数据，然后再去更新缓存。
2. 此时我们发现缓存更新失败了，咱们就将其重新放到消息队列中。
3. 单独写一个消费者接收更新失败记录，然后进行重试更新操作。

说到消息队列重试，还有一种方式是基于异步任务重试，咱们可以把更新缓存失败的这个数据保存到数据库，然后通过另外的一个定时任务进而扫描待执行任务，然后去做相关的缓存更新动作。

当然上面我们提到的这两种方案，其实比较依赖我们的业务代码做出相对应的调整。我们当然也可以借助Canal组件来监控MySQL中的binlog的日志。通过数据库的 binlog 来异步淘汰 key，利用工具(canal)将 binlog日志采集发送到 MQ 中，然后通过 ACK 机制确认处理删除缓存。先更新DB，然后再去更新缓存，这种方式，被称为 Cache Aside Pattern，属于缓存更新的经典设计模式之一。

![基于canal](https://cdn.ktdaddy.com/cache/cache07.png)

## 方案小结并且推荐一个缓存开发框架
上述我们总结了缓存使用的一些方案，我们发现其实没有一种方案是完美的，最完美的方案其实还是得去结合具体的业务场景去使用。方案已经同步了，那么如何去撸数据库以及缓存同步的代码呢？接下来，和大家分享的当然是日常开发中比较好用的SpringCache缓存处理框架了。

## SpringCache实战
SpringCache是一个框架，实现了基于注解缓存功能，只需要简单地加一个注解，就能实现缓存功能。
SpringCache提高了一层抽象，底层可以切换不同的cache实现，具体就是通过cacheManager接口来统一不同的缓存技术
cacheManager是spring提供的各种缓存技术抽象接口。


### 配置
我们日常开发中用到比较多的其实是redis作为缓存，所以咱们就可以用RedisCacheManager，当然cacheManager也提供其他缓存，例如GuavaCaceManager，EhCacheCacheManager，这里感兴趣的小伙伴可以自行去查阅一下这两种方式的写法。

老猫这里拿看一下redisCacheManager来举例，项目开始的时候我们当忽然要在pom文件依赖的时候就肯定需要redis启用项。如下：
```xml
       <!-- 配置redis缓存时 -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis</artifactId>
        </dependency>
```

### 常用注解
关于SpringCache常用的注解，老猫整理罗列了一下。如下:

![SpringCache常用注解](https://cdn.ktdaddy.com/cache/cache08.png)