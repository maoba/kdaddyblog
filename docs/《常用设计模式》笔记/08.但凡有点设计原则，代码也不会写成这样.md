---
title: 但凡有点设计原则，系统也不会写成这样
date: 2024-02-06 22:05:02
permalink: /pages/b468e6/
categories:
  - 《常用设计模式》笔记
tags:
  - 设计模式
  - 软件设计原则
author: 
  name: 老猫
  link: https://github.com/maoba
---
## 故事
这段时间以来，小猫按照之前的系统梳理方案【[系统梳理大法](https://mp.weixin.qq.com/s/3b4d69K-fhQshswhrUrFHg)&[代码梳理大法](https://mp.weixin.qq.com/s/Xi-DV4UqKXr_W-L0xBhRWA)】一直在整理着文档。

系统中涉及的业务以及模型也基本了然于胸，但是这代码写的真的是...

小猫也终于知道了为什么每天都有客诉，为什么每天都要去调用curl语句去订正生产的数据，为什么每天都在Hotfix...

整理了一下，大概出于这些原因，业务流程复杂暂且不议，光从技术角度来看，整个代码体系臃肿不堪，出问题之后定位困难，后面接手的几任开发为了解决问题都是“曲线救国”，不从正面去解决问题，为了解决一时的客诉问题而去解决问题，于是定义了各种新的修复流程去解决问题，这么一来，软件系统“无序”总量一直在增加，整个系统体系其实在初版之后就已经在“腐烂”了，如此？且抛开运维稳定性不谈，就系统本身稳定性而言，能好？

所以那两次事故还真不能怪小猫【[事故1](https://mp.weixin.qq.com/s/b3dOUC24Erbz4JAAtXLkMQ),[事故2](https://mp.weixin.qq.com/s/3b4d69K-fhQshswhrUrFHg)】

整个系统，除了堆业务还是堆业务，但凡有点软件设计原则，系统也不会写成这样了。

## 关于设计原则
大家在产品提出需求之后，一般都会去设计数据模型，还有系统流程。但是各位有没有深度去设计一下代码的实现呢？还是说上手就直接照着流程图开始撸业务了？估计有很多的小伙伴由于各种原因不会去考虑代码设计，其实老猫很多时候也一样。主要原因比如：项目催的紧，哪有时间考虑那么多，功能先做出来，剩下的等到后面慢慢优化。然而随着时间的推移，我们会发现我们一直很忙，说好的把以前的代码重构好一点，哪有时间！于是，就这样“技术债”越来越多，就像滚雪球一样，整个系统逐渐“腐烂”到了根。最终坑的可能是自己，也有可能是“下一个他”。

虽然在日常开发的时候项目进度比较紧张，我们很多时候也不去深度设计代码实现，但是我们在写代码的时候保证心中有一杆秤其实还是必要的。

那咱们就结合各种案来聊聊“这杆秤”————软件设计原则。

//解决我，我这里还需要一张图

下面我们通过各种小例子来协助大家理解软件设计原则，案例是老猫构想的，有的时候不要太过较真，主要目的是讲清楚原则。

## 开闭原则
开闭原则，英文(Open-Closed Principle,简称：OCP)。只要指一个软件实体（例如，类，模块和函数），应该对扩展开放，对修改关闭。其重点强调的是抽象构建框架，实现扩展细节，从而提升软件系统的可复用性以及可维护性。

概念是抽象，但是案例是具体的，所以咱们直接看案例，通过案例去理解可能更容易。

由于小猫最近在维护商城类业务，所以咱们就从商品折价售卖这个案例出发。业务是这样的，商城需要对商品进行做打折活动，目前针对不同品类的商品可能打折的力度不一样，例如生活用品和汽车用品的打折情况不同。
创建一个基础商品接口：
```java
public interface IProduct {
    String getSpuCode(); //获取商品编号
    String getSpuName(); //获取商品名称
    BigDecimal getPrice(); //获取商品价格
}
```
基础商品实现该接口,于是我们就有了如下代码：
```java
/**
 * @Author: 公众号：程序员老猫
 * @Date: 2024/2/7 23:39
 */
public class Product implements IProduct {
    private String spuCode;
    private String spuName;
    private BigDecimal price;
    private Integer categoryTag;

    public Product(String spuCode, String spuName, BigDecimal price, Integer categoryTag) {
        this.spuCode = spuCode;
        this.spuName = spuName;
        this.price = price;
        this.categoryTag = categoryTag;
    }

    public Integer getCategoryTag() {
        return categoryTag;
    }

    @Override
    public String getSpuCode() {
        return spuCode;
    }

    @Override
    public String getSpuName() {
        return spuName;
    }

    @Override
    public BigDecimal getPrice() {
        return price;
    }
}
```
按照上面的业务，现在搞活动，咱们需要针对不同品类的商品进行促销活动，例如生活用品需要进行折扣。于是我们就可以如此拓展。
```java 
public class DailyDiscountProduct extends Product {
    private static final BigDecimal daily_discount_factor = new BigDecimal(0.95);
    private static final Integer DAILY_PRODUCT = 1;

    public DailyDiscountProduct(String spuCode, String spuName, BigDecimal price) {
        super(spuCode, spuName, price, DAILY_PRODUCT);
    }

    @Override
    public BigDecimal getPrice() {
        return super.getPrice().multiply(daily_discount_factor);
    }
}
```
上面我们看到直接打折的日常用品的商品继承了标准商品，并且对其进行了价格重写，这样就完成了生活用品的打折。当然这种打折系数的话我们一般可以配置到数据库中。

对汽车用品的打折其实也是一样的实现。继承之后重写价格即可。咱们并不需要去基础商品Product中根据不同的品类去更改商品的价格。

<strong>错误案例</strong>，

如果我们一味地在原始类别上去做逻辑应该就是如下这样：
```java

public class Product implements IProduct {
    private static final Integer DAILY_PRODUCT = 1;
    private static final BigDecimal daily_discount_factor = new BigDecimal(0.95);
    private String spuCode;
    private String spuName;
    private BigDecimal price;
    private Integer categoryTag;
    ....
    @Override
    public BigDecimal getPrice() {
      if(categotyTag.equals(DAILY_PRODUCT)){
        return price.multiply(daily_discount_factor);
      }
      return price;
    }
}
```
后续随着业务的演化，我们一直在改当前类，代码越堆越多，越来越臃肿，这种实现方式就破坏了开闭原则。